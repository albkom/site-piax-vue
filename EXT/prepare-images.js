import fs from 'fs'
import path from 'path'
const dir = './IMAGES'
const outputFile = '../src/db/db.images.ts'
const publicDir = '../public/img'

function getAllFiles(dirPath, arrayOfFiles = []) {
  console.log(dirPath)
  const files = fs.readdirSync(dirPath)
  files.forEach((file) => {
    const fullPath = path.join(dirPath, file)
    if (fs.statSync(fullPath).isDirectory()) {
      getAllFiles(fullPath, arrayOfFiles)
    } else {
      // Store relative path from imagesDir
      arrayOfFiles.push(path.relative(dir, fullPath).replace(/\\/g, '/'))
    }
  })
  return arrayOfFiles
}

const files = getAllFiles(dir)

const grouped = files.reduce((acc, file) => {
  const [folder, ...rest] = file.split('/');
  if (!acc[folder]) acc[folder] = { mobile: [], desktop: [] };
  if (file.toLowerCase().includes('mobile')) {
    acc[folder].mobile.push(file);
  } else if (file.toLowerCase().includes('desktop')) {
    acc[folder].desktop.push(file);
  }
  return acc;
}, {});

const content = `// Auto-generated by prepare-images.js
export type ImageGroup = {
  mobile: string[];
  desktop: string[];
};
export const images: Record<string, ImageGroup> = ${JSON.stringify(grouped, null, 2)};
`

fs.writeFileSync(outputFile, content, 'utf8')
console.log(`Exported ${files.length} images to images.ts`)

if (fs.existsSync(publicDir)) {
  fs.readdirSync(publicDir).forEach((file) => {
    const fullPath = path.join(publicDir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      fs.rmSync(fullPath, { recursive: true, force: true });
    }
  });
}

fs.readdirSync(dir).forEach((folder) => {
  const src = path.join(dir, folder);
  const dest = path.join(publicDir, folder);
  if (fs.statSync(src).isDirectory()) {
    fs.cpSync(src, dest, { recursive: true });
  }
});

const herosDir = './HEROS';
const herosOutputFile = '../src/db/db.heros.ts';

function getHeroFiles(dirPath, arrayOfFiles = []) {
  if (!fs.existsSync(dirPath)) return arrayOfFiles;
  const files = fs.readdirSync(dirPath);
  files.forEach((file) => {
    const fullPath = path.join(dirPath, file);
    if (fs.statSync(fullPath).isDirectory()) {
      getHeroFiles(fullPath, arrayOfFiles);
    } else {
      arrayOfFiles.push(path.relative(herosDir, fullPath).replace(/\\/g, '/'));
    }
  });
  return arrayOfFiles;
}

const heroFiles = getHeroFiles(herosDir);
const prefix = 'hero'

const heroGrouped = heroFiles.reduce(
  (acc, file) => {
    if (file.toLowerCase().includes('mobile')) {
      acc.mobile.push(`${prefix}${file}`);
    } else if (file.toLowerCase().includes('desktop')) {
      acc.desktop.push(`${prefix}${file}`);
    }
    return acc;
  },
  { mobile: [], desktop: [] }
);

const herosContent = `// Auto-generated by prepare-images.js
export type ImageGroup = {
  mobile: string[];
  desktop: string[];
};
export const heros: ImageGroup = ${JSON.stringify(heroGrouped, null, 2)};
`;

fs.writeFileSync(herosOutputFile, herosContent, 'utf8');
console.log(`Exported ${heroFiles.length} hero images to db.heros.ts`);

if (fs.existsSync(herosDir)) {
  const dest = path.join(publicDir, 'HEROS');
  if (fs.existsSync(dest)) {
    fs.rmSync(dest, { recursive: true, force: true });
  }
  fs.mkdirSync(dest, { recursive: true });

  fs.readdirSync(herosDir).forEach((file) => {
    const srcPath = path.join(herosDir, file);
    if (fs.statSync(srcPath).isFile()) {
      const destPath = path.join(publicDir, `${prefix}${file}`);
      fs.copyFileSync(srcPath, destPath);
    }
  });

  console.log(`Copied hero files to ${dest} with 'hero' prefix`);
}
